## 请你说说线程和协程的区别

> `线程`是操作系统内核进行命令执行调度的单位，
>
> `协程`是程序内的一种抽象，通过记录程序运行上下文状态信息，模拟多线程执行

协程与线程的区别: 

-  一个线程可以有多个协程，一个进程也可以单独拥有多个协程。
- 线程的切换需要在**内核态**进行，而协程的切换是**用户态**(完全被程序进行控制)，协程是轻量级线程。 
- 线程进程都是同步机制，而协程则是异步。 
- 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
- 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 
- 协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。 
- 线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。
- 协程在一个线程中执行，消除了线程切换的开销，性能优势明显。
- 协程不需要多线程的锁机制，具有极高的执行效率



## 请你说说多线程

`进程`是操作系统资源调度的基本单位,`线程`是操作系统调度的最小单元,它可以让一个进程并发地处理多个任务,也叫`轻量级进程`。所以,在一个进程里可以创建多个线程,这些线程都拥有各自的`程序计数器`、`堆栈`、`局部变量表`,并且能够共享进程内的资源。由于共享资源,处理器便可以在这些线程之间快速切换,从而让使用者感觉这些线程在同时执行。 

总的来说,操作系统可以同时执行多个任务,每个任务就是一个进程。进程可以同时执行多个任务,每个任务就是一个线程。一个程序运行之后至少有一个进程,而一个进程可以包含多个线程,但至少要包含一个线程。 使用多线会给开发人员带来显著的好处,而使用多线程的原因主要有以下几点：

1. 更多的CPU核心 现代计算机处理器性能的提升方式,已经从追求更高的主频向追求更多的核心发展,所以处理器的核心数量会越来越多,充分地利用处理器的核心则会显著地提高程序的性能。而程序使用多线程技术,就可以将计算逻辑分配到多个处理器核心上,显著减少程序的处理时间,从而随着更多处理器核心的加入而变得更有效率。
2. 可以把复杂的业务逻辑种的对数据一致性要求不强的操作，比如生成订单快照分配给其他的线程去处理（也可以使用消息队列），极大的提高了程序的响应时间 
3. java提供了一个良好的多线程模型，能是开发者专注于业务的开发

缺点：

- 可能产生死锁；
- 频繁的上下文切换可能会造成资源的浪费；
- 在并发编程中如果因为资源的限制，多线程串行执行，可能速度会比单线程更慢。



## 说说怎么保证线程安全

> 线程安全问题是指在多线程背景下，线程没有按照我们的预期执行，导致操作共享变量出现异常。

在Java中有许多同步方案提供给我们使用，从轻到重有三种方式：原子类、volatile关键字、锁。 

- 原子类是juc atomic包下的一系列类，通过CAS比较与交换的机制实现线程安全的更新共享变量。通过预期值与内存值的比较来判断是否修改。
- volatile关键字是轻量级的同步机制，他实现了变量的可见性、防止指令重排序。保证了【单个变量】读写的线程安全。可见性问题是JMM内存模型中定义每个核心存在一个内存副本导致的，核心只操作他们的内存副本，volatile保证了一旦修改变量则立即刷新到共享内存中，且其他核心的内存副本失效，需要重新读取([关于volatile如何实现可见性可以点此查看](http://vchicken.cn/note/#/java/JUC/volatile%E8%AF%A6%E8%A7%A3?id=volatile-%e5%8f%af%e8%a7%81%e6%80%a7%e5%ae%9e%e7%8e%b0))。 
- 原子类和volatile只能保证单个共享变量的线程安全，锁则可以保证临界区内的多个共享变量线程安全。java中常用的锁有两种：synchronized关键字+juc包下的lock锁。
  - synchronized锁是互斥锁，可以作用于实例方法、静态方法、代码块，基于对象头和Monitor对象，在1.6之后引入轻量级锁、偏向锁等优化。
  - lock锁接口可以通过lock、unlock方法锁住一段代码，基于AQS实现，其加锁解锁就是操作AQS的state变量，并且将阻塞队列存在AQS的双向队列中。
  - 除了锁以外，juc包下还提供了一些线程同步工具类，如CountDownLatch（允许一个或多个线程等待其他线程完成操作）、Semaphore（就是信号量,可以控制同时访问特定资源的线程数量）、CyclicBarrier（让一组线程到达一个屏障时被阻塞,直到最后一个线程到达屏障时,屏障才会打开,所有被屏障拦截的线程才会继续运行）等等，我们还可以使用ThreadLocal定义线程局部变量！([详情可阅读此文](http://vchicken.cn/note/#/java/JUC/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AF%A6%E8%A7%A3))



## 请你说说进程间的通信方式

进程间通信主要包括：`管道`、`命名管道`、`信号`、`消息队列`、`共享内存`、`内存映射`、`信号量`、`Socket`。

1. **管道** 

   管道也叫无名（匿名）管道,它是是 UNIX 系统 IPC（进程间通信）的最古老形式,所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。 

2. **命名管道** 

   匿名管道,由于没有名字,只能用于亲缘关系的进程间通信。为了克服这个缺点,提出了有名管道（FIFO）,也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联,以 FIFO 的文件形式存在于文件系统中,并且其打开方式与打开一个普通文件是一样的,这样即使与 FIFO 的创建进程不存在亲缘关系的进程,只要可以访问该路径,就能够彼此通过 FIFO 相互通信,因此,通过 FIFO 不相关的进程也能交换数据。 

3. **信号** 

   信号是 Linux 进程间通信的最古老的方式之一,是事件发生时对进程的通知机制,有时也称之为软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。 

4. **消息队列** 

   消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息,消息队列是随内核持续的。 

5. **共享内存** 

   共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分,因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中,并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比,这种 IPC 技术的速度更快。 

6. **内存映射** 

   内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件。 

7. **信号量** 

   信号量主要用来解决进程和线程间并发执行时的同步问题,进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后,再进行 P 操作时,当前进程或线程会被阻塞,直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。 

8. **Socket** 

   套接字（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端,提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。