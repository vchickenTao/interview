## 面向对象

---

### Java 有哪些特点

- `并发性的`：你可以在其中执行许多语句，而不必一次执行它
- `面向对象的`：基于类和面向对象的编程语言。
- `独立性的`：支持一次编写，到处运行的独立编程语言，即编译后的代码可以在支持 Java 的所有平台上运行。

![Image](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-10-11/aea0d2a3-78f8-4f8d-8aeb-efe9979ecc5f_interview-javabase-01.png)

### Java 的特性

Java 的特性有如下这几点

- `简单`，Java 会让你的工作变得更加轻松，使你把关注点放在主要业务逻辑上，而不必关心指针、运算符重载、内存回收等与主要业务无关的功能。
- `便携性`，Java 是平台无关性的，这意味着在一个平台上编写的任何应用程序都可以轻松移植到另一个平台上。
- `安全性`， 编译后会将所有的代码转换为字节码，人类无法读取。它使开发无病毒，无篡改的系统/应用成为可能。
- `动态性`，它具有适应不断变化的环境的能力，它能够支持动态内存分配，从而减少了内存浪费，提高了应用程序的性能。
- `分布式`，Java 提供的功能有助于创建分布式应用。使用`远程方法调用（RMI）`，程序可以通过网络调用另一个程序的方法并获取输出。您可以通过从互联网上的任何计算机上调用方法来访问文件。这是革命性的一个特点，对于当今的互联网来说太重要了。
- `健壮性`，Java 有强大的内存管理功能，在编译和运行时检查代码，它有助于消除错误。
- `高性能`，Java 最黑的科技就是字节码编程，Java 代码编译成的字节码可以轻松转换为本地机器代码。通过 JIT 即时编译器来实现高性能。
- `解释性`，Java 被编译成字节码，由 Java 运行时环境解释。
- `多线程性`，Java支持多个执行线程（也称为轻量级进程），包括一组同步原语。这使得使用线程编程更加容易，Java 通过管程模型来实现线程安全性。



### JDK和JRE和JVM的区别

1.`JDK(Java Development Kit)`是java开发工具包，JDK包括JRE，类库，java工具,所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等。
2.`JRE(Java Runtime Environment)`是java运行时环境，包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等。
3.JVM（Java Virtual Machine）是Java虚拟机。在倒数第二层 由他可以在（最后一层的）各种平台上运行 Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。
![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-15/30239126-8e3d-43b5-b7d3-c06be44c4ea7.png)



### 面向对象

**1.什么是面向对象？**
说到面向对象，那么我们就不得不先提到面向过程，例如我们学过的最基础的编程语言——`C语言`，就是一种面向过程的语言。那么面向对象和面向过程有什么区别呢？

- `面向过程`是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

  ```java
  例如：一个事情，妈妈叫孩子起床吃饭，那么按照面向过程的思想，那我们需要至少按照以下步骤进行：
     1.妈妈先起床；
     2.妈妈洗漱；
     3.妈妈准备早餐；
     4.叫孩子起床；
     5.孩子起床；
     6.孩子洗漱；
     7.孩子吃饭。
  ```

- `面向对象`是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。

  ```java
    同样的事情，只需要一个步骤：
    妈妈叫孩子吃饭
    其中，妈妈需要做的事情都在妈妈对象中，孩子需要做的事情都在孩子对象中。
  ```

- 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。

**2.面向对象和面向过程的优缺点**

**1. 面向过程：**

   - **优点**：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
   - **缺点：**没有面向对象易维护、易复用、易扩展。

**2. 面向对象：**

   - **优点**：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。
   - **缺点：**性能比面向过程低。

**3.面向对象的特性**

- **封装**： 封装的意义，在于明确标识出允许外部使用属性和方法，内部细节对外部调用透明，外部调用无需修改或者关心内部的实现。

  - javabean的属性私有，只提供get和set供外部调用，属性的赋值和逻辑只能由javabean自身决定，不能由外部胡乱修改；
  - ORM框架，例如mybatis，操作数据库，我们不需要关心链接是怎么建立的/sql是怎么执行的，只需要引入mybatis，调用方法即可。

- **继承**： 继承基类的方法，并做出自己的改变或者拓展。子类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

- **多态**：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。

  1. java如何实现多态？

    - 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用**在编译时并不确定**，而是**在程序运行期间才确定**，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，**不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上**，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。
    - 多态分为`编译时多态`和`运行时多态`。其中编译时多态是**静态**的，主要是指**方法的重载**，它是根据**参数列表的不同来区分不同的函数**，通过编译之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是**动态**的，它是通过动态绑定来实现的，也就是我们所说的多态性。

  2. 多态的实现

    - 多态的实现要满足三个条件：
      1. 继承
      2. 重写
      3. 向上转型（父类引用指向子类对象）

```java
父类类型 变量名 = new 子类对象；
变量名.子类方法名()；
无法调用子类中的特有方法，即父类中没有的方法，可以理解为为满足重写条件
```

**4.面向对象的七大原则**

**一 开闭原则(The Open-Closed Principle ，OCP)**
**开闭原则**：软件实体应当对扩展开放，对修改关闭。
根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。

- **扩展开放**：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。
- **修改关闭**：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求模块是修改关闭的。

**二 单一职责原则（Single Responsibility Principle，SRP）**

单一职责原则是最简单的面向对象设计原则，它用于`控制类的粒度大小`，将对象解耦，提高内聚性。
单一职责原则：**一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中**。
该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

- 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
- 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

**三 里氏替换原则（Liskov Substitution Principle ，LSP）**

**里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象**
符合条件：

  1. 不应该在代码中出现if/else之类对派生类类型进行判断的条件。
  2. 派生类应当可以替换基类并出现在基类能够出现的任何地方

**四 迪米特原则（最少知道原则）（Law of Demeter ，LoD）**

**迪米特原则：talk only to your immediate friends，只与你直接的朋友们通信，不要跟“陌生人”说话。**
一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
迪米特法则中的“朋友”是指：**当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等**，这些对象同当前对象存在`关联、聚合或组合关系`，可以直接访问这些对象的方法。

**五 接口隔离原则(Interface Segregation Principle, ISP)**

**接口隔离原则：**使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。(要为各个类建立它们需要的专用接口)

**六 依赖倒置原则（Dependency Inversion Principle ，DIP）**

**依赖倒置原则：**高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。（面向接口/抽象编程，不要面向实现（实现类）编程）

**七 合成复用原则（Composite/Aggregate Reuse Principle ，CARP）**

**合成复用原则：**尽量使用对象组合或者聚合等关联关系，而不是继承来达到复用的目的。





### 内部类有哪些分类，分别解释一下

在 Java 中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。

内部类的分类一般主要有四种

- 成员内部类
- 局部内部类
- 匿名内部类
- 静态内部类

`静态内部类`就是定义在类内部的静态类，静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；

`成员内部类` 就是定义在类内部，成员位置上的非静态类，就是成员内部类。成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。

定义在方法中的内部类，就是`局部内部类`。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。

`匿名内部类` 就是没有名字的内部类，除了没有名字，匿名内部类还有以下特点：

- 匿名内部类必须继承一个抽象类或者实现一个接口
- 匿名内部类不能定义任何静态成员和静态方法。
- 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。
- 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

```java
/**
 * @Description Testlambda
 * @Author vchicken
 * @Date 2022/8/30 19:31
 */
public class TestLambda {

    //3.静态内部类
    static class Like2 implements ILike {
        @Override
        public void lambda() {
            System.out.println(" I like lambda2");
        }
    }

    public static void main(String[] args) {
        ILike like = new Like();
        like.lambda();

        like = new Like2();
        like.lambda();

        //4.局部内部类
        class Like3 implements ILike {
            @Override
            public void lambda() {
                System.out.println(" I like lambda3");
            }
        }

        like = new Like3();
        like.lambda();

        //5.匿名内部类,没有类的名称，必须借助接口或者父类
        like = new ILike() {
            @Override
            public void lambda() {
                System.out.println(" I like lambda4");
            }
        };

        like.lambda();

        //6.用lambda表达式
        like = ()->{
            System.out.println(" i like lambda5");
        };
        like.lambda();
    }
}

//1.定义一个函数式接口
interface ILike {
    void lambda();
}

//2.实现类
class Like implements ILike {

    @Override
    public void lambda() {
        System.out.println(" I like lambda");
    }
}
```



### 描述一下值传递和引用传递的区别

要想真正理解的话，可以参考这篇文章 ：https://www.zhihu.com/question/31203609

简单理解的话就是

`值传递`是指在调用函数时将实际参数复制一份到函数中，这样的话如果函数对其传递过来的形式参数进行修改，将不会影响到实际参数

`引用传递` 是指在调用函数时将对象的地址直接传递到函数中，如果在对形式参数进行修改，将影响到实际参数的值。

> [!ATTENTION] Java只有值传递



#### == 和 equals() 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

**`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。

`Object` 类 `equals()` 方法：



```java
public boolean equals(Object obj) {
     return (this == obj);
}
```

`equals()` 方法存在两种使用情况：

- **类没有重写 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
- **类重写了 `equals()`方法** ：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 `==` 换成 `equals()` ）：



```java
String a = new String("ab"); // a 为一个引用
String b = new String("ab"); // b为另一个引用,对象的内容一样
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true
```

`String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。

`String`类`equals()`方法：



```java
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

#### hashCode() 有什么用？

`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。

`hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是： `Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

```java
public native int hashCode();
```

散列表存储的是键值对(key-value)，它的特点是：**能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）**

#### 为什么要有 hashCode？

我们以“`HashSet` 如何检查重复”为例子来说明为什么要有 `hashCode`？

下面这段内容摘自我的 Java 启蒙书《Head First Java》:

> 当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。

**那为什么 JDK 还要同时提供这两个方法呢？**

这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）！

我们在前面也提到了添加元素进`HashSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。也就是说 `hashCode` 帮助我们大大缩小了查找成本。

**那为什么不只提供 `hashCode()` 方法呢？**

这是因为两个对象的`hashCode` 值相等并不代表两个对象就相等。

**那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？**

因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 `hashCode` )。

总结下来就是 ：

- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。

相信大家看了我前面对 `hashCode()` 和 `equals()` 的介绍之后，下面这个问题已经难不倒你们了。

#### 为什么重写 equals() 时必须重写 hashCode() 方法？

因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

**思考** ：重写 `equals()` 时没有重写 `hashCode()` 方法的话，使用 `HashMap` 可能会出现什么问题。

**总结** ：

- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。



#### String 中的 equals 是如何重写的

String 代表的是 Java 中的`字符串`，String 类比较特殊，它整个类都是被 `final` 修饰的，也就是说，String 不能被任何类继承，任何 `修改` String 字符串的方法都是创建了一个新的字符串。

equals 方法是 Object 类定义的方法，Object 是所有类的父类，当然也包括 String，String 重写了 `equals` 方法，下面我们来看看是怎么重写的

![Image](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-10-11/d6c92467-677c-4377-84f6-93cda405fb1c_interview-javabase-02.png)

- 首先会判断要比较的两个字符串它们的`引用`是否相等。如果引用相等的话，直接返回 true ，不相等的话继续下面的判断
- 然后再判断被比较的对象是否是 String 的实例，如果不是的话直接返回 false，如果是的话，再比较两个字符串的长度是否相等，如果长度不想等的话也就没有比较的必要了；长度如果相同，会比较字符串中的每个 `字符` 是否相等，一旦有一个字符不相等，就会直接返回 false。

下面是它的流程图

![Image](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-10-11/40d42add-205d-443e-8bd7-44e61f30e717_interview-javabase-03.png)

这里再提示一下，你可能有疑惑什么时候是

```java
if (this == anObject) {
  return true;
}
```

这个判断语句如何才能返回 true？因为都是字符串啊，字符串比较的不都是堆空间吗，猛然一看发现好像永远也不会走，但是你忘记了 `String.intern()` 方法，它表示的概念在不同的 JDK 版本有不同的区分

在 JDK1.7 及以后调用 intern 方法是判断运行时常量池中是否有指定的字符串，如果没有的话，就把字符串添加到常量池中，并返回常量池中的对象。

验证过程如下

```java
private void StringOverrideEquals(){

  String s1 = "aaa";
  String s2 = "aa" + new String("a");
  String s3 = new String("aaa");

  System.out.println(s1.intern().equals(s1));
  System.out.println(s1.intern().equals(s2));
  System.out.println(s3.intern().equals(s1));

}
```

- 首先 s1.intern.equals(s1) 这个无论如何都返回 true，因为 s1 字符串创建出来就已经在常量池中存在了。

- 然后第二条语句返回 false，因为 s1 返回的是常量池中的对象，而 s2 返回的是堆中的对象

- 第三条语句 s3.intern.equals(s1)，返回 true ，因为 s3 对象虽然在堆中创建了一个对象，但是 s3 中的 "aaa" 返回的是常量池中的对象。

  ![Image](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-10-11/55377921-2134-4a00-8bc8-3ff8db8af82e_interview-javabase-04.png)



### String s1 = new String("abc") 在内存中创建了几个对象

一个或者两个，String s1 是声明了一个 String 类型的 s1 变量，它不是对象。使用 `new` 关键字会在堆中创建一个对象，另外一个对象是 `abc` ，它会在常量池中创建，所以一共创建了两个对象；如果 abc 在常量池中已经存在的话，那么就会创建一个对象。

### String 为什么是不可变的、jdk 源码中的 String 如何定义的、为什么这么设计。

首先了解一下什么是`不可变对象`，不可变对象就是一经创建后，其对象的内部状态不能被修改，啥意思呢？也就是说不可变对象需要遵守下面几条原则

- 不可变对象的内部属性都是 final 的
- 不可变对象的内部属性都是 private 的
- 不可变对象不能提供任何可以修改内部状态的方法、setter 方法也不行
- 不可变对象不能被继承和扩展

与其说问 String 为什么是不可变的，不如说如何把 String 设计成不可变的。

String 类是一种对象，它是独立于 Java 基本数据类型而存在的，String 你可以把它理解为字符串的集合，String 被设计为 final 的，表示 String 对象一经创建后，它的值就不能再被修改，任何对 String 值进行修改的方法就是重新创建一个字符串。String 对象创建后会存在于运行时常量池中，运行时常量池是属于方法区的一部分，JDK1.7 后把它移到了堆中。

不可变对象不是真的不可变，可以通过`反射`来对其内部的属性和值进行修改，不过一般我们不这样做。



### String、StringBuffer与StringBuilder的区别？

**可变性**

`String` 是不可变的。

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    public AbstractStringBuilder append(String str) {
        if (str == null)
            return appendNull();
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }
  	//...
}
```

**线程安全性**

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`



### static 关键字是干什么用的？谈谈你的理解

static 是 Java 中非常重要的关键字，static 表示的概念是 `静态的`，在 Java 中，static 主要用来

- 修饰变量，static 修饰的变量称为`静态变量`、也称为`类变量`，类变量属于类所有，对于不同的类来说，static 变量只有一份，static 修饰的变量位于方法区中；static 修饰的变量能够直接通过 类名.变量名 来进行访问，不用通过实例化类再进行使用。
- 修饰方法，static 修饰的方法被称为`静态方法`，静态方法能够直接通过 类名.方法名来使用，在静态方法内部不能使用非静态属性和方法
- static 可以修饰代码块，主要分为两种，一种直接定义在类中，使用 `static{}`，这种被称为`静态代码块`，一种是在类中定义`静态内部类`，使用 `static class xxx` 来进行定义。
- static 可以用于静态导包，通过使用 `import static xxx` 来实现，这种方式一般不推荐使用
- static 可以和单例模式一起使用，通过双重检查锁来实现线程安全的单例模式。



### final 关键字是干什么用的？谈谈你的理解

final 是 Java 中的关键字，它表示的意思是 `不可变的`，在 Java 中，final 主要用来

- 修饰类，final 修饰的类不能被继承，不能被继承的意思就是不能使用 `extends` 来继承被 final 修饰的类。
- 修饰变量，final 修饰的变量不能被改写，不能被改写的意思有两种，对于基本数据类型来说，final 修饰的变量，其值不能被改变，final 修饰的对象，对象的引用不能被改变，但是对象内部的属性可以被修改。final 修饰的变量在某种程度上起到了`不可变`的效果，所以，可以用来保护只读数据，尤其是在并发编程中，因为明确的不能再为 final 变量进行赋值，有利于减少额外的同步开销。
- 修饰方法，final 修饰的方法不能被重写。
- final 修饰符和 Java 程序性能优化没有必然联系

### 抽象类和接口的区别是什么

1、抽象类中可以包含**普通方法**，但接口中只能**包含public与abstract方法**(JDK 1.8之前)，JDK1.8之后允许接口中出现**default方法**;

2、抽象类中的成员变量没有访问权限的限制，但接口中的变量只能被public static final修饰;

3、一个接口可以继承多个接口，但一个类只能有一个父类，类可以实现多个接口;

4、抽象类是**对一类事物的抽象**，接口则是**对行为的抽象**。一个类继承一个抽象类代表“`是不是`”的关系，而一个类实现一个接口则表示“`有没有`”的关系。

核心区别: **抽象类中可以包含`普通方法`和`普通字段`, 这样的普通方法和字段可以被子类直接使用(不必重写), 而接口中不能包含普通方法, 子类必须重写所有的抽象方法**。



### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

关于深拷贝和浅拷贝区别，我这里先给结论：

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！

**浅拷贝**

浅拷贝的示例代码如下，我们这里实现了 `Cloneable` 接口，并重写了 `clone()` 方法。

`clone()` 方法的实现很简单，直接调用的是父类 `Object` 的 `clone()` 方法。

```java
public class Address implements Cloneable{
    private String name;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Address clone() {
        try {
            return (Address) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

public class Person implements Cloneable {
    private Address address;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Person clone() {
        try {
            Person person = (Person) super.clone();
            return person;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

测试 ：

```java
Person person1 = new Person(new Address("武汉"));
Person person1Copy = person1.clone();
// true
System.out.println(person1.getAddress() == person1Copy.getAddress());
```

从输出结构就可以看出， `person1` 的克隆对象和 `person1` 使用的仍然是同一个 `Address` 对象。

**深拷贝**

这里我们简单对 `Person` 类的 `clone()` 方法进行修改，连带着要把 `Person` 对象内部的 `Address` 对象一起复制。

```java
@Override
public Person clone() {
    try {
        Person person = (Person) super.clone();
        person.setAddress(person.getAddress().clone());
        return person;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```

测试 ：

```java
Person person1 = new Person(new Address("武汉"));
Person person1Copy = person1.clone();
// false
System.out.println(person1.getAddress() == person1Copy.getAddress());
```

从输出结构就可以看出，虽然 `person1` 的克隆对象和 `person1` 包含的 `Address` 对象已经是不同的了。

**那什么是引用拷贝呢？** 简单来说，引用拷贝就是两个不同的引用指向同一个对象。

我专门画了一张图来描述浅拷贝、深拷贝、引用拷贝：

![浅拷贝、深拷贝、引用拷贝示意图](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/shallow&deep-copy.png)

意思是说switch的编译会用到两个指令，`tablesswitch`和`lookupswitch`。而这2个指令指令只会运行在int指令下，低于int的正数类型会被转为int类型，而这一点和short、byte等类型在计算时会被转为int来处理的表现是一致的。
到此为止，我们知道第一个问题的答案了。在编译时，switch被编译成对应的2个实现方式的指令，这2种指令只支持int类型。




### 重写和重载的区别

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

**重载**

发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

《Java 核心技术》这本书是这样介绍重载的：

> 如果多个方法(比如 `StringBuilder` 的构造方法)有相同的名字、不同的参数， 便产生了重载。
>
> ```java
> StringBuilder sb = new StringBuilder();
> StringBuilder sb2 = new StringBuilder("HelloWorld");
> ```
>
> 编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。
>
> Java 允许重载任何方法， 而不只是构造器方法。

综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。

**重写**

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

综上：**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期   | 运行期                                                       |

**方法的重写要遵循“两同两小一大”**（以下内容摘录自《疯狂 Java 讲义》，[issue#892open in new window](https://github.com/Snailclimb/JavaGuide/issues/892) ）：

- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

⭐️ 关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

```java
public class Hero {
    public String name() {
        return "超级英雄";
    }
}
public class SuperMan extends Hero{
    @Override
    public String name() {
        return "超人";
    }
    public Hero hero() {
        return new Hero();
    }
}

public class SuperSuperMan extends SuperMan {
    public String name() {
        return "超级超级英雄";
    }

    @Override
    public SuperMan hero() {
        return new SuperMan();
    }
}
```



### byte的取值范围是多少，怎么计算出来的

byte 的取值范围是 -128 -> 127 之间，一共是 256 。一个 byte 类型在计算机中占据一个字节，那么就是 8 bit，所以最大就是 2^7 = 1111 1111。

Java 中用`补码`来表示二进制数，补码的最高位是符号位，最高位用 0 表示正数，最高位 1 表示负数，正数的补码就是其`本身`，由于最高位是符号位，所以正数表示的就是 0111 1111 ，也就是 127。最大负数就是 1111 1111，这其中会涉及到两个 0 ，一个 +0 ，一个 -0 ，+0 归为正数，也就是 0 ，-0 归为负数，也就是 -128，所以 byte 的范围就是 -128 - 127。



### int 和 Integer 的区别

int 和 Integer 区别可就太多了

- int 是 Java 中的基本数据类型，int 代表的是 `整型`，一个 int 占 4 字节，也就是 32 位，int 的初始值是默认值是 0 ，int 在 Java 内存模型中被分配在栈中，int 没有方法。
- Integer 是 Java 中的基本数据类型的包装类，Integer 是一个对象，Integer 可以进行方法调用，Integer 的默认值是 null，Integer 在 Java 内存模型中被分配在堆中。int 和 Integer 在计算时可以进行相互转换，int -> Integer 的过程称为 `装箱`，Integer -> int 的过程称为 `拆箱`，Integer 还有 IntegerCache ，会自动缓存 -128 - 127 中的值



### 包装类型的缓存机制了解么？

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

**Integer 缓存源码：**

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static {
        // high value may be configured by property
        int h = 127;
    }
}
```

**`Character` 缓存源码:**

```java
public static Character valueOf(char c) {
    if (c <= 127) { // must cache
      return CharacterCache.cache[(int)c];
    }
    return new Character(c);
}

private static class CharacterCache {
    private CharacterCache(){}
    static final Character cache[] = new Character[127 + 1];
    static {
        for (int i = 0; i < cache.length; i++)
            cache[i] = new Character((char)i);
    }

}
```

**`Boolean` 缓存源码：**

```java
public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
}
```

如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。

两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制。

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```

下面我们来看一下问题。下面的代码的输出结果是 `true` 还是 `false` 呢？

```java
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);
```

`Integer i1=40` 这一行代码会发生装箱，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是缓存中的对象。而`Integer i2 = new Integer(40)` 会直接创建新的对象。

因此，答案是 `false` 。你答对了吗？

记住：**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**。

![img](https://img-blog.csdnimg.cn/20210422164544846.png)



### UTF-8 和 Unicode 的关系

由于每个国家都有自己独有的字符编码，所以Unicode 的发展旨在创建一个新的标准，用来映射当今使用的大多数语言中的字符，这些字符有一些不是必要的，但是对于创建文本来说却是不可或缺的。Unicode 统一了所有字符的编码，是一个 Character Set，也就是字符集，字符集只是给所有的字符一个唯一编号，但是却没有规定如何存储，不同的字符其存储空间不一样，有的需要一个字节就能存储，有的则需要2、3、4个字节。

UTF-8 只是众多能够对文本字符进行`解码`的一种方式，它是一种变长的方式。UTF-8 代表 8 位一组表示 Unicode 字符的格式，使用 1 - 4 个字节来表示字符。

```java
U+ 0000 ~ U+ 007F: 0XXXXXXX
U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
```

可以看到，UTF-8 通过开头的标志位位数实现了变长。对于单字节字符，只占用一个字节，实现了向下兼容 ASCII，并且能和 UTF-32 一样，包含 Unicode 中的所有字符，又能有效减少存储传输过程中占用的空间。

### 项目为 UTF-8 环境，char c = '中'，是否合法

可以，因为 Unicode 编码采用 2 个字节的编码，UTF-8 是 Unicode 的一种实现，它使用可变长度的字符集进行编码，char c = '中' 是两个字节，所以能够存储。合法。



### 不同编码方式对应所占字节数

①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。

②UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。

③Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。

符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。

④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。

⑤UTF-32编码中，世界上任何字符的存储都需要4个字节。



## 异常体系

---

### Java 异常类层次结构图概览

![Java 异常类层次结构图](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/types-of-exceptions-in-java.png)

### Exception 和 Error 有什么区别？

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类:

- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
- **`Error`** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获不建议通过`catch`捕获 。例如 Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

### Checked Exception 和 Unchecked Exception 有什么区别？

**Checked Exception** 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 `catch`或者`throws` 关键字处理的话，就没办法通过编译。

比如下面这段 IO 操作的代码：

![img](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/checked-exception.png)

除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、`ClassNotFoundException` 、`SQLException`...。

**Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。

`RuntimeException` 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：

- `NullPointerException`(空指针错误)
- `IllegalArgumentException`(参数错误比如方法入参类型错误)
- `NumberFormatException`（字符串转换为数字格式错误，`IllegalArgumentException`的子类）
- `ArrayIndexOutOfBoundsException`（数组越界错误）
- `ClassCastException`（类型转换错误）
- `ArithmeticException`（算术错误）
- `SecurityException` （安全错误比如权限不够）
- `UnsupportedOperationException`(不支持的操作错误比如重复创建同一用户)
- ......

![img](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/unchecked-exception.png)

### Throwable 类常用方法有哪些？

- `String getMessage()`: 返回异常发生时的简要描述
- `String toString()`: 返回异常发生时的详细信息
- `String getLocalizedMessage()`: 返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同
- `void printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息



### 说出几种常用的异常

- NullPointerException: 空指针异常
- NoSuchMethodException：找不到方法
- IllegalArgumentException：不合法的参数异常
- IndexOutOfBoundException: 数组下标越界异常
- IOException：由于文件未找到、未打开或者I/O操作不能进行而引起异常
- ClassNotFoundException ：找不到文件所抛出的异常
- NumberFormatException：字符的UTF代码数据格式有错引起异常；
- InterruptedException：线程中断抛出的异常


### 聊聊Java的switch为什么不支持long
1.为什么可以支持byte、char、short、int，不能支持long呢？

发现一个共同点，这些都是基础数据类型中的整数，并且最大不超过int。正好去研究一下官方文档说明。
Compilation of switch statements uses the tableswitch and lookupswitch instructions.
The tableswitch instruction is used when the cases of the switch can be efficiently represented as indices into a table of target offsets.
The default target of the switch is used if the value of the expression of the switch falls outside the range of valid indices.
The Java Virtual Machine's tableswitch and lookupswitch instructions operate only on int data. Because operations on byte, char, or short values are internally promoted to int, a switch whose expression evaluates to one of those types is compiled as though it evaluated to type int.

###  try-catch-finally 如何使用？

- `try`块 ： 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
- `catch`块 ： 用于处理 try 捕获到的异常。
- `finally` 块 ： 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

代码示例：

```java
try {
    System.out.println("Try to do something");
    throw new RuntimeException("RuntimeException");
} catch (Exception e) {
    System.out.println("Catch Exception -> " + e.getMessage());
} finally {
    System.out.println("Finally");
}
```

输出：

```text
Try to do something
Catch Exception -> RuntimeException
Finally
```

**注意：不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

[jvm 官方文档open in new window](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.10.2.5)中有明确提到：

> If the `try` clause executes a *return*, the compiled code does the following:
>
> 1. Saves the return value (if any) in a local variable.
> 2. Executes a *jsr* to the code for the `finally` clause.
> 3. Upon return from the `finally` clause, returns the value saved in the local variable.

代码示例：

```java
public static void main(String[] args) {
    System.out.println(f(2));
}

public static int f(int value) {
    try {
        return value * value;
    } finally {
        if (value == 2) {
            return 0;
        }
    }
}
```

输出：

```text
0
```



### finally 中的代码一定会执行吗？

不一定的！在某些情况下，finally 中的代码不会被执行。

就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。

```java
try {
    System.out.println("Try to do something");
    throw new RuntimeException("RuntimeException");
} catch (Exception e) {
    System.out.println("Catch Exception -> " + e.getMessage());
    // 终止当前正在运行的Java虚拟机
    System.exit(1);
} finally {
    System.out.println("Finally");
}
```

输出：

```text
Try to do something
Catch Exception -> RuntimeException
```

另外，在以下 2 种特殊情况下，`finally` 块的代码也不会被执行：

1. 程序所在的线程死亡。
2. 关闭 CPU。



### 如何使用 `try-with-resources` 代替`try-catch-finally`？

1. **适用范围（资源的定义）：** 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象
2. **关闭资源和 finally 块的执行顺序：** 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行

《Effective Java》中明确指出：

> 面对必须要关闭的资源，我们总是应该优先使用 `try-with-resources` 而不是`try-finally`。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。`try-with-resources`语句让我们更容易编写必须要关闭的资源的代码，若采用`try-finally`则几乎做不到这点。

Java 中类似于`InputStream`、`OutputStream` 、`Scanner` 、`PrintWriter`等的资源都需要我们调用`close()`方法来手动关闭，一般情况下我们都是通过`try-catch-finally`语句来实现这个需求，如下：

```java
//读取文本文件的内容
Scanner scanner = null;
try {
    scanner = new Scanner(new File("D://read.txt"));
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (scanner != null) {
        scanner.close();
    }
}
```

使用 Java 7 之后的 `try-with-resources` 语句改造上面的代码:

```java
try (Scanner scanner = new Scanner(new File("test.txt"))) {
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException fnfe) {
    fnfe.printStackTrace();
}
```

当然多个资源需要关闭的时候，使用 `try-with-resources` 实现起来也非常简单，如果你还是用`try-catch-finally`可能会带来很多问题。

通过使用分号分隔，可以在`try-with-resources`块中声明多个资源。

```java
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
    int b;
    while ((b = bin.read()) != -1) {
        bout.write(b);
    }
}
catch (IOException e) {
    e.printStackTrace();
}
```

### 异常使用有哪些需要注意的地方？

- 不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。
- 抛出的异常信息一定要有意义。
- 建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出`NumberFormatException`而不是其父类`IllegalArgumentException`。
- 使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。
- .....



### final、finally 和 finalize() 的区别

这三者可以说是没有任何关联之处，我们上面谈到了，final 可以用来修饰类、变量和方法，可以参考上面 final 的那道面试题。

finally 是一个关键字，它经常和 try 块一起使用，用于异常处理。使用 try...finally 的代码块种，finally 部分的代码一定会被执行，所以我们经常在 finally 方法中用于资源的关闭操作。

JDK1.7 中，推荐使用 `try-with-resources` 优雅的关闭资源，它直接使用 try(){} 进行资源的关闭即可，就不用写 finally 关键字了。

finalize 是 Object 对象中的一个方法，用于对象的回收方法，这个方法我们一般不推荐使用，finalize 是和垃圾回收关联在一起的，在 Java 9 中，将 finalize 标记为了 `deprecated`， 如果没有特别原因，不要实现 finalize 方法，也不要指望他来进行垃圾回收。



## 泛型

---

### 什么是泛型？有什么作用？

**Java 泛型（Generics）** 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。

编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 `ArrayList<Persion> persons = new ArrayList<Persion>()` 这行代码就指明了该 `ArrayList` 对象只能传入 `Persion` 对象，如果传入其他类型的对象就会报错。

```java
ArrayList<E> extends AbstractList<E>
```

并且，原生 `List` 返回类型是 `Object` ，需要手动转换类型才能使用，使用泛型后编译器自动转换。



### 泛型中extends和super的区别

1. `<? extends T>`表示包括T在内的任何T的子类
2. `<? super T>`表示包括T在内的任何T的父类



### 泛型的使用方式有哪几种？

泛型一般有三种使用方式:**泛型类**、**泛型接口**、**泛型方法**。

**1.泛型类**：

```java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}
```

如何实例化泛型类：

```java
Generic<Integer> genericInteger = new Generic<Integer>(123456);
```

**2.泛型接口** ：

```java
public interface Generator<T> {
    public T method();
}
```

实现泛型接口，不指定类型：

```java
class GeneratorImpl<T> implements Generator<T>{
    @Override
    public T method() {
        return null;
    }
}
```

实现泛型接口，指定类型：

```java
class GeneratorImpl<T> implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}
```

**3.泛型方法** ：

```java
   public static < E > void printArray( E[] inputArray )
   {
         for ( E element : inputArray ){
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
```

使用：

```java
// 创建不同类型数组： Integer, Double 和 Character
Integer[] intArray = { 1, 2, 3 };
String[] stringArray = { "Hello", "World" };
printArray( intArray  );
printArray( stringArray  );
```

> 注意: `public static < E > void printArray( E[] inputArray )` 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 `<E>`

### 项目中哪里用到了泛型？

- 自定义接口通用返回结果 `CommonResult<T>` 通过参数 `T` 可根据具体的返回类型动态指定结果的数据类型
- 定义 `Excel` 处理类 `ExcelUtil<T>` 用于动态指定 `Excel` 导出的数据类型
- 构建集合工具类（参考 `Collections` 中的 `sort`, `binarySearch` 方法）。
- .....



## Object类

---

### Object 类中一般都有哪些方法

Object 类是所有对象的父类，它里面包含一些所有对象都能够使用的方法

- hashCode()：用于计算对象的哈希码
- equals()：用于对象之间比较值是否相等
- toString(): 用于把对象转换成为字符串
- clone(): 用于对象之间的拷贝
- wait(): 用于实现对象之间的等待
- notify(): 用于通知对象释放资源
- notifyAll(): 用于通知所有对象释放资源
- finalize(): 用于告知垃圾回收器进行垃圾回收
- getClass(): 用于获得对象类



## 反射机制

---

### 反射的基本原理，反射创建类实例的三种方式是什么

反射机制就是使 Java 程序在运行时具有`自省(introspect)` 的能力，通过反射我们可以直接操作类和对象，比如获取某个类的定义，获取类的属性和方法，构造方法等。

创建类实例的三种方式是

- 对象实例.getClass()；
- 通过 Class.forName() 创建
- 对象实例.newInstance() 方法创建



### 反射的优缺点？

反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。

不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。



### 反射的应用场景？

像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。

**这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。**

比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 `Method` 来调用指定的方法。

```java
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
    }
}
```

另外，像 Java 中的一大利器 **注解** 的实现也用到了反射。

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。



### 动态代理是基于什么原理

代理一般分为`静态代理`和 `动态代理`，它们都是代理模式的一种应用，静态代理指的是在程序运行前已经编译好，程序知道由谁来执行代理方法。

而动态代理只有在程序运行期间才能确定，相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。可以说动态代理是基于 `反射` 实现的。通过反射我们可以直接操作类或者对象，比如获取类的定义，获取声明的属性和方法，调用方法，在运行时可以修改类的定义。

动态代理是一种在运行时构建代理、动态处理方法调用的机制。动态代理的实现方式有很多，Java 提供的代理被称为 `JDK 动态代理`，JDK 动态代理是基于类的继承。



### 6.List，Set，Map三者的区别

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-15/93333f7e-7fbc-4393-8246-9cdbf887f757.png)
![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-15/a5fe36e0-e61f-4348-93ee-06793db30786.png)

- Java容器分为Collection和Map两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口；
- **Collection集合**主要有`List`和`Set`两大接口：
  - **List**：一个**有序**（元素存入集合的顺序和取出的顺序一致）容器，**元素可以重复**，**可以插入多个null元素**，元素都有索引。常用的实现类有 `ArrayList`、`LinkedList` 和 `Vector`;
  - **Set**：一个**无序**（存入和取出顺序有可能不一致，TreeSet例外，它是有序的）容器，**不可以存储重复元素**，**只允许存入一个null元素**，必须保证元素唯一性。Set 接口常用实现类是 `HashSet`、`LinkedHashSet` 以及`TreeSet`。
- **Map**是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象
  - Map的常用实现类：`HashMap`、`TreeMap`、`HashTable`、`LinkedHashMap`、`ConcurrentHashMap`。

### 7.集合框架底层数据结构

- **Collection**
  - **List**
    1. **Arraylist**： Object数组
    2. **Vector**： Object数组
    3. **LinkedList**： 双向循环链表
- **Set**
  - **HashSet（无序，唯一）**：基于HashMap 实现的，底层采用 HashMap来保存元素
  - **LinkedHashSet**： LinkedHashSet继承自HashSet，并且其内部是通过LinkedHashMap来实现的。有点类似于我们之前说的LinkedHashMap其内部是基于HashMap实现一样，不过还是有一点点区别的
  - **TreeSet（有序，唯一）**： 红黑树(自平衡的排序二叉树。)
- **Map**
  - **HashMap**： JDK1.8之前HashMap由**数组+链表**组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，**当链表长度大于阈值（默认为8）时，将链表转化为红黑树**，以减少搜索时间
  - **LinkedHashMap**：LinkedHashMap继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，**增加了一条双向链表**，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑
  - **HashTable**： **数组+链表**组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的
  - **TreeMap**： 红黑树（自平衡的排序二叉树）

### 8.哪些集合类是线程安全的？

- **Vector**：就比Arraylist多了个 synchronized （线程安全），因为效率较低，现在已经不太建议使用
- **HashTable**：就比hashMap多了个synchronized (线程安全)，不建议使用
- **ConcurrentHashMap**：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）

### 9.Java集合的快速失败机制 “fail-fast”

<a herf="https://blog.csdn.net/qq_45649807/article/details/126211551">Java集合的快速失败机制</a>

### 10.ArrayList和LinkedList的区别

- 首先，他们的底层数据结构不同，前者是基于数组实现的，后者是基于链表实现的；
- 由于底层数据结构不同，他们所适用的场景也不同，前者适合随机查找，后者则更适合删除和添加，查询/添加/删除的时间复杂度不同；
- 另外两者都实现了List接口，但是后者还额外实现了Deque接口，所以后者还可以当做队列来使用。

### 11.谈谈ConcurrentHashMap的扩容机制

- **JDK1.7**：
  1. 1.7版本的ConcurrentHashMap是基于Segment分段实现的
  2. 每个Segment相对于⼀个⼩型的HashMap
  3. 每个Segment内部会进⾏扩容，和HashMap的扩容逻辑类似
  4. 先⽣成新的数组，然后转移元素到新数组中
  5. 扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值
- **JDK1.8**：
  1. 1.8版本的ConcurrentHashMap不再基于Segment实现
  2. 当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容
  3. 如果某个线程put时，发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然 后判断是否超过阈值，超过了则进⾏扩容
  4. ConcurrentHashMap是⽀持多个线程同时扩容的
  5. 扩容之前也先⽣成⼀个新的数组
  6. 在转移元素时，先将原数组分组，将每组分给不同的线程来进⾏元素的转移，每个线程负责⼀组或 多组的元素转移⼯作

### 12.HashMap的扩容机制原理

- **JDK1.7版本**
  1. 先⽣成新数组
  2. 遍历老数组中的每个位置上的链表上的每个元素
  3. 取每个元素的key，并基于新数组⻓度，计算出每个元素在新数组中的  下标
  4. 将元素添加到新数组中去
  5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

- **JDK1.8版本**
  1. 先生成新数组
  2. 遍历老数组中的每个位置上的链表或红⿊树
  3. 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去
  4. 如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置
     a. 统计每个下标位置的元素个数
     b. 如果该位置下的元素个数超过了8，则⽣成⼀个新的红黑树，并将根节点的添加到新数组的对应位置
     c. 如果该位置下的元素个数没有超过8，那么则⽣成⼀个链表，并将链表的头节点添加到新数组的对应位置
  5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

### 13.JDK1.7到JDK1.8 HashMap发生了说明变化？

- 1.7版本底层数据结构是**数组+链表**，1.8之后底层变为**数组+链表+红黑树**，加入红黑树整体提高了hashmap**插入和查询效率**。
- 1.7链表结构中插入采用的是**头插法**，1.8之后插入采用**尾插法**，因为jdk1.8种插入元素需要遍历整个链表统计元素个数，所以正好采用尾插法。
- 1.7种哈希算法比较复杂，存在各种右移异或运算，1.8中进行的简化，复杂哈希算法是为了提高散列性，来提升hashmap整体效率，1.8中加入了红黑树，所以可以适当简化哈希算法，节省cpu利用率。
  ![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-16/c6da9782-2478-4c9c-a633-207cd5f044f6.png)

### 14.CopyOnWriteArrayList的底层原理是怎样的

1、⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制⼀个新的数组，写操作在新数组上进行，读操作在原数组上进⾏
2、并且，写操作会加锁，防止出现并发写入丢失数据的问题
3、写操作结束之后会把原数组指向新数组
CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景。

### 15.深拷贝和浅拷贝的区别

`深拷贝`和`浅拷贝`就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。

1. 浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象
2. 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象

### 16.什么是字节码？采用字节码的最大好处是什么？

- **字节码**：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机，可以做到一次编译到处运行。
- **采用字节码的好处**：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，编译器在编译源代码时可以做一些编译期的优化，比如`锁消除`，`标量替换`，`方法内联`等。同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行，实现了跨平台。
- **先看下java中的编译器和解释器**：Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

### 17.Java中的异常体系是怎样的

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-17/4023279a-5735-4759-8068-4d2e7ee2e381.png)

1. `Thorwable`类（表示可抛出）是所有异常和错误的超类，两个直接子类为`Error`和`Exception`，分别表示**错误**和**异常**。
2. 其中异常类Exception又分为**运行时异常**(RuntimeException)和**非运行时异常**， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。
3. **Error错误:** 描述了Java运行时系统的内部错误和资源耗尽错误。一般是指虚拟机（JVM）相关的问题，如系统崩溃，虚拟机出错误等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常不处理。因为如果出现这样的内部错误，除了通告用户，并尽力使程序安全地终止之外，再也无能为力了。
4. **Exception异常：** Java的异常分为两种，checked Exception（编译时异常也叫非运行时异常）和 RuntimeException（运行时异常）。这种异常是可以靠程序自己来解决的，我们可以选择捕获这些异常做特殊处理。
5. **运行时异常**（逻辑方面）都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是**非检查异常**，程序中可以选择捕获处理，也可以不处理。这些异常一般是由**程序逻辑错误**引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
6. **非运行时异常**（程序语法）是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，**如果不处理，程序就不能编译通过**。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。




2.为什么可支持enum和String？

按照反编译对照来看，enum最终也是转换为enum的int序号来适应switch的。而String类型要怎么和int对应起来呢，有一种方式叫hashcode计算，最后可以得出一个数值，把这个控制在int范围内，就能适应switch的要求了。

### 参考资料

- [Java面试题硬核全梳理 ~](https://mp.weixin.qq.com/s/p1zxnGVeTDJiyjgowRIoBA)
- [这10道基础Java面试题，虐哭了多少人](https://mp.weixin.qq.com/s/oBDrFnuk1lbfuNHkrhAC5w)